<html>
<head>
  <title>chap8Linux磁盘与文件系统管理</title>
  <basefont face="微软雅黑" size="2">
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name="exporter-version" content="Evernote Windows/274507; Windows/6.3.9600;">
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="326">
<h1>chap8Linux磁盘与文件系统管理</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><ul><li>Linux最传统的磁盘文件系统是EXT2</li><li>文件系统的特性</li><li style="list-style: none; display: inline"><ul><li>分区&amp;文件系统</li><li style="list-style: none; display: inline"><ul><li>传统磁盘和文件系统中，一个分区只能被格式化成一个文件系统</li><li style="list-style: none; display: inline"><ul><li>以前“格式化”是针对“分区”而言的，一个文件系统即是一个分区</li></ul></li><li>新的技术诸如LVM与软磁盘阵列（software raid），使得一个分区可以格式化成多个文件系统，也可以将多个分区合成一个文件系统</li><li style="list-style: none; display: inline"><ul><li>如今“格式化”是针对“一个可被挂载的数据”，一个文件系统是一个可被挂载的数据</li></ul></li></ul></li><li>操作系统所设置的文件属性/权限   与   实际数据通常是存放在不同的块中</li><li>索引式文件系统</li><li style="list-style: none; display: inline"><ul><li>super block：记录文件系统的整体信息，包括inode/block总量、使用量、剩余量，以及文件系统的格式与相关信息等</li><li>inode：记录文件的属性，和文件数据所在的block号码（一个文件占用一个inode）</li><li>block：实际记录文件内容，若文件太大，会占用多个block</li><li>文件系统中的inode单独存放，访问数据时先在inode中找到文件对应的block号码，再去访问block中文件的数据</li><li style="list-style: none; display: inline"><ul><li>compare：惯用文件系统如FAT</li><li style="list-style: none; display: inline"><ul><li>每个block号码记录在前一个block中</li><li style="list-style: none; display: inline"><ul><li>如先访问block1，得知下一个block为4，前往后得知再下一个block为7，以此类推</li></ul></li><li>没办法一次性知道4个block的号码</li></ul></li></ul></li></ul></li><li>碎片整理</li><li style="list-style: none; display: inline"><ul><li>原因：文件写入的block太过于离散，导致文件读取的性能将会变得很差</li><li>目的：将同一个文件所属的block汇合在一起</li><li>FAT经常需要碎片整理，而EXT2基本上不太需要碎片整理，但是文件系统使用太久，经常删除/编辑/新增文件时，仍然有可能造成文件数据太过离散，偶尔还是需要碎片整理的</li></ul></li></ul></li><li>EXT2文件系统</li><li style="list-style: none; display: inline"><ul><li>格式化时就将inode与block规划好，除非重新格式化或者利用resize2fs等命令更改文件系统大小，否则inode与block将固定不变</li><li>文件系统格式化时会划分为多个块组（block group）</li><li style="list-style: none; display: inline"><ul><li>解决inode与block数量太大而不易管理的问题</li><li>每个块组有独立的inode/block/super block系统</li><li>文件系统的最前面有一个启动扇区（boot sector），可以安装引导装载程序</li><li style="list-style: none; display: inline"><ul><li>super block大小为1024bytes</li><li>super block前端也需要留出1024bytes作为boot sector</li><li>当block为1K时</li><li style="list-style: none; display: inline"><ul><li>super block没有多余的空间来作为boot sector</li><li>所以在super block之前需要多空处一个block来作为boot sector</li></ul></li><li>当block大于2K（2K / 4K）时</li><li style="list-style: none; display: inline"><ul><li>super block有足够的空间来给boot sector</li><li>所以boot sector与super block为同一block</li><li>boot sector位于该block的最前端</li></ul></li><li>所以，“引导装载程序可以安装到super block内”的说法并不完全正确</li><li>更为正确的说法是“可以安装到该文件系统最前面的1024bytes内的区域”</li></ul></li><li>每个block group依次分为以下六个区段</li><li style="list-style: none; display: inline"><ul><li>super block（大小为1024bytes）</li><li style="list-style: none; display: inline"><ul><li>记录整个文件系统的基本信息，包括</li><li style="list-style: none; display: inline"><ul><li>block与inode的总量</li><li>未使用/已使用的block/inode数量</li><li>block与inode的大小</li><li style="list-style: none; display: inline"><ul><li>block为1K, 2K, 4K</li><li>inode为128bytes</li></ul></li><li>文件系统的挂载时间、最后一次写入数据的时间、最后一次检验磁盘（fsck）的时间等</li><li>一个valid bit数值，</li><li style="list-style: none; display: inline"><ul><li>若文件系统已被挂载，其值为0</li><li>若文件系统没被挂载，其值为1</li></ul></li></ul></li><li>一般只有第一个block group内含有super block</li><li style="list-style: none; display: inline"><ul><li>若其他block group含有super block，则主要是作为备份，方便进行super block的救援</li></ul></li></ul></li><li>file system description（文件系统描述说明）</li><li style="list-style: none; display: inline"><ul><li>每个block group的开始与结束block号</li><li>每个区段分别介于哪一个block号码之间</li></ul></li><li>block bitmap（块对照表）</li><li style="list-style: none; display: inline"><ul><li>记录空闲的block号码，和占用的block号码</li></ul></li><li>inode bitmap（inode对照表）</li><li style="list-style: none; display: inline"><ul><li>记录空闲的inode号码，和占用的inode号码</li></ul></li><li>inode table（inode表格</li><li style="list-style: none; display: inline"><ul><li>主要记录各个文件的基本信息</li><li style="list-style: none; display: inline"><ul><li>访问模式（read/write/excute）</li><li>所有者与组（owner/group）</li><li>大小</li><li>ctime，atime，mtime</li><li>定义文件的特性标志，如SUID等</li><li>实际内容的指向（block号码）</li></ul></li><li>inode的特性</li><li style="list-style: none; display: inline"><ul><li>inode的数量和大小在格式化时固定</li><li>每个inode大小都为128bytes（2^7bytes）</li><li>每个文件仅占用一个inode</li><li>文件系统能够创建的数量受到inode数量的限制</li><li>inode每记录一个block号码占用4bytes</li></ul></li><li>间接指向</li><li style="list-style: none; display: inline"><ul><li>再拿一个block来当记录block号码的记录区</li><li>类似“扩展分区”</li></ul></li><li>系统支持最大单一文件的大小与block大小有关</li><li style="list-style: none; display: inline"><ul><li>其总额为直接、间接、双间接、三间接指向的block的大小之和</li><li>如对于1K的block：总额=12+256+256^2+256^3(K) = 16GB</li><li>2K与4K的block受到文件系统本身的限制，不能采取相同的方法计算</li></ul></li></ul></li><li>data block（数据块）</li><li style="list-style: none; display: inline"><ul><li>目前支持的block大小有1K, 2K, 4K三种</li><li><table border="1" cellpadding="2" cellspacing="0" style="text-align: center;" width="100%"><tbody><tr><td style="text-align: center;" valign="top">Block大小</td><td style="text-align: center;" valign="top">1KB</td><td style="text-align: center;" valign="top">2KB</td><td style="text-align: center;" valign="top">4KB</td></tr><tr><td style="text-align: center;" valign="top">最大单一文件限制</td><td style="text-align: center;" valign="top">16GB</td><td style="text-align: center;" valign="top">256GB</td><td style="text-align: center;" valign="top">2TB</td></tr><tr><td style="text-align: center;" valign="top">最大文件系统总容量</td><td style="text-align: center;" valign="top">2TB</td><td style="text-align: center;" valign="top">8TB</td><td style="text-align: center;" valign="top">16TB</td></tr></tbody></table><br></li><li>某些应用程序沿用旧限制，只支持2GB以下的单一文件，无关文件系统</li><li>原则上，block的大小与数量在格式化时已经固定</li><li>每个block至多存放一个文件的数据</li><li>如果文件大于block大小，将占用多个block</li><li>如果文件小于block大小，剩余的空间并不能被利用，磁盘空间被浪费</li><li style="list-style: none; display: inline"><ul><li>文件大小 &amp; 占用空间</li><li>用“ll -s”查看目录下的数据时，第一列数据total指的是占用空间</li><li>用“du”查看占用空间时，-b是用bytes计算的文件大小，而-k和-m是通过block计算的占用空间</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>查询文件系统的信息：dumpe2fs</li><li style="list-style: none; display: inline"><ul><li>基本语法：dumpe2fs [-bh] devname</li><li style="list-style: none; display: inline"><ul><li>-b：列出保留为坏道的部分</li><li>-h：仅列出super block的数据，不列出其他区段</li></ul></li><li>主要信息</li><li style="list-style: none; display: inline"><ul><li>Fliesystem volume name：文件系统的命令，即Label</li><li>Default mount option：默认挂载的参数</li><li>Filesystem state：文件系统的状态（clean为正常，dirty为异常）</li><li>Block size：每个block的大小（bytes）</li><li>Inode size：每个inode的大小（bytes）</li><li>注意：号码都是以0为起始</li></ul></li></ul></li><li>EXT2与directroy tree的关系</li><li style="list-style: none; display: inline"><ul><li>新建目录</li><li style="list-style: none; display: inline"><ul><li>EXT2会分配一个inode和至少一个block给该目录</li><li>inode记录该目录的相关权限和属性，还有分配到的block号码</li><li>block用来记录目录下的文件名与该文件的inode号码</li><li> </li><li>每新建一个目录，该目录的连接数为2（.和目录名），上层目录的连接数+1（..）</li><li>（.）和（..）是实际存在的文件（symbolic link）而不是记号</li><li>如果不人为地为目录建立连接，那么  该目录下的子目录数 = 该目录连接数（包括(.)和(..)）</li></ul></li><li>新建文件</li><li style="list-style: none; display: inline"><ul><li>EXT2会分配一个inode和与文件大小相对用的block数量</li><li>inode记录该文件的相关权限和属性，还有分配到的block号码</li><li>block用来记录该文件的实际数据</li><li>注意：inode仅有12直接指向，若有更多数据，需要额外占用block作为号码记录区</li></ul></li><li>目录树读取</li><li style="list-style: none; display: inline"><ul><li>系统通过挂载信息找到挂载点的inode号码</li><li style="list-style: none; display: inline"><ul><li>通常一个文件系统的inode号码从2号开始</li></ul></li><li>读取挂载点的inode内容，找到下一层目录的inode号码</li><li>再读取下一层目录inode内容</li><li>……（以此类推，直到文件所在目录）</li><li>读取目录的inode内容，找到文件的inode号码</li><li>读取文件的inode内容，找到文件对应的block号码</li><li>访问相应的block，读取文件数据</li><li>  </li><li>注意：每次读取目录、文件的inode，会先判断是否具有相应权限，再决定是否进行一下步</li></ul></li><li>文件系统大小与磁盘读取性能</li><li style="list-style: none; display: inline"><ul><li>由于硬盘数据经常变动，所以整个文件系统上的文件通常无法连续写在一起，而是填入式地把数据放入空白的block</li><li>如果文件写入的block太分散，就存在文件数据离散的问题</li><li>解决方法：可以把整个文件系统内的数据移出，重新格式化后把数据复制回来</li><li>注意：分区规划不是越大越好，应根据用途来规划</li></ul></li><li>新建目录或文件</li><li style="list-style: none; display: inline"><ul><li>先确定用户在该目录下是否具有w与x的权限</li><li>根据inode bitmap找到空白的inode号码，写入新文件的权限和属性</li><li>根据block bitmap找到空白的block号码，将实际数据写入block中，并更新inode的block指向数据</li><li>将写入的inode与block数据，同步更新inode bitmap和block bitmap，并更新super block的内容</li></ul></li><li>挂载点（mount point）</li><li style="list-style: none; display: inline"><ul><li>挂载：将文件系统与目录树结合</li><li>挂载点一定是目录，该目录为进入该文件系统的入口</li><li>文件系统必须要挂载到目录树的某个目录后才能使用</li><li>同一个文件系统的某个inode只能对应一个文件内容</li><li style="list-style: none; display: inline"><ul><li>我们可以通过inode号码来确认同一目录下的不同文件名是否为同一文件</li></ul></li></ul></li></ul></li><li>EXT3日志文件系统（journaling file system）</li><li style="list-style: none; display: inline"><ul><li>一般我们将inode table与data block称为数据存放区域</li><li>而super block、block bitmap、inode bitmap等区段就被称为metadata（中间数据）</li><li style="list-style: none; display: inline"><ul><li>其中数据经常变动，每次添加、删除、编辑时都可能影响这三部分的数据</li></ul></li><li>数据不一致状态</li><li style="list-style: none; display: inline"><ul><li>由于不明原因导致系统中断，使数据存放区域与中间数据不一致</li><li>在EXT2文件系统中</li><li style="list-style: none; display: inline"><ul><li>系统会在重启时，会通过super block中记录的valid bit（是否有挂载）与文件系统的state（clean与否）等状态来判断是否强制用e2fsck进行数据一致性检查</li><li>不过这种检查相当费时，因为要搜寻整个文件系统进行数据比对</li></ul></li><li>在EXT3文件系统中</li><li style="list-style: none; display: inline"><ul><li>规划出了一个块用来记录写入或者修订文件的步骤，万一数据记录发生问题，系统只需要检查日志记录块就可以知道问题在哪，有针对性的进行数据已执行检查，极大的缩短了修复时间</li></ul></li></ul></li><li>工作过程</li><li style="list-style: none; display: inline"><ul><li>预备：当系统要写入文件时，会先在journaling file system中记录某个文件准备要写入的信息</li><li>实际写入：开始写入文件的权限与数据；    开始更新meta data的数据</li><li>结束：完成数据与meta data数据的更新后，在日志记录块中完成该文件的记录</li></ul></li><li>优点：可利用性、数据完整性、速度、易于转换（无需重新格式化，直接规划出一个块即可）</li></ul></li><li>异步处理</li><li style="list-style: none; display: inline"><ul><li>系统将常用的文件数据放置到主存储器的缓冲区，以加速文件系统的读写</li><li>若文件没被更改过，文件数据会设置为clean</li><li>若文件被修改过，文件数据会设置为dirty，此时操作都在内存中进行，不定时地将内存中为dirty的数据写回磁盘中</li><li>可以手动使用sync命令强迫内存将dirty的数据写入磁盘中</li><li>正常关机时，关机命令会主动调用sync来将内存数据回写入磁盘内</li><li>若不正常关机，由于数据尚未回写到磁盘内，因此重启后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁（不是磁盘损坏）</li></ul></li><li>Linux支持的文件系统与VFS</li><li style="list-style: none; display: inline"><ul><li>传统文件系统：EXT2、minix、MS-DOS、FAT（vfat模块）、iso9660（光盘）等</li><li>日志文件系统：EXT3、ReiserFS、Windows'NTFS、IBM'sJFS、SGI'sXFS</li><li>网络文件系统：NFS、SMBFS</li><li>查看支持的文件系统</li><li style="list-style: none; display: inline"><ul><li>ls -l /lib/modules/$(sname -r)/kernel/fs</li></ul></li><li>查看系统目前已加载到内存的文件系统</li><li style="list-style: none; display: inline"><ul><li>cat /proc/filesystems</li></ul></li><li>Virtual Filesystem Switch（虚拟文件系统，VFS）</li><li style="list-style: none; display: inline"><ul><li>Linux都是通过VFS的内核功能去读取文件系统的</li><li>VFS能够自动识别并使用相应的文件系统模块去读取文件系统</li></ul></li></ul></li><li>查看文件系统的整体使用量：df</li><li style="list-style: none; display: inline"><ul><li>基本语法：df [-ahikHTm] dirname/filename</li><li style="list-style: none; display: inline"><ul><li>-a：列出所有文件系统，包括/proc等</li><li style="list-style: none; display: inline"><ul><li>此时/proc等目录大小为0，是因为他们在内存内，不占用磁盘空间</li></ul></li><li>-k：以KB的容量显示</li><li>-m：以MB的容量显示</li><li>-h：自动使用GB、MB、KB的容量显示</li><li>-H：用1000进位而非1024进位来显示</li><li>-T：（Type）显示文件系统类型</li><li>-i：（inode）显示inode数量，不显示磁盘容量</li></ul></li><li>不带参数，“df”默认表示将系统内所有的（除了内存内的文件系统和swap）都以KB的容量显示出来</li><li>主要信息</li><li style="list-style: none; display: inline"><ul><li>1k-blocks：说明下面的数字单位是1KB</li><li>Mounted on：挂载点</li></ul></li><li>主要读取的是super block内的信息，所以命令的处理速度很快</li><li>/dev/shm 目录是利用内存虚拟出来的磁盘空间，其内容开机时就被清空</li></ul></li><li>查看文件系统的占用容量（只显示容量）：du</li><li style="list-style: none; display: inline"><ul><li>基本语法：du [-ahskm] dirname/filename</li><li style="list-style: none; display: inline"><ul><li>-a：列出所有的文件与目录容量</li><li style="list-style: none; display: inline"><ul><li>默认仅显示文件，而不显示目录</li></ul></li><li>-h：自动使用G/M的容量来显示</li><li>-s：只列出该目录的总量</li><li>-S：不重新计算子目录，减少计算</li><li>-k：以KB列出容量显示</li><li>-m：以MB列出容量显示</li><li>-b：以bytes列出容量显示</li></ul></li><li>不加任何参数即“du”命令为分析当前目录的文件与目录，但只显示目录容量，以KB为单位</li><li>该命令与df不同，是直接到文件系统内查找文件数据</li><li>示例：du -sm /*</li><li style="list-style: none; display: inline"><ul><li>以MB为单位显示目录下所有子目录的容量</li></ul></li></ul></li><li>连接文件：ln</li><li style="list-style: none; display: inline"><ul><li>连接文件有两种</li><li style="list-style: none; display: inline"><ul><li>符号连接（symbolic link）</li><li style="list-style: none; display: inline"><ul><li>类似Windows的快捷方式的新文件，两文件的inode号码不同</li><li>该文件内的数据只是指向的文件的路径</li><li style="list-style: none; display: inline"><ul><li>如指向/etc/crontab，路径占用12个字符，那么该符号连接文件为12bytes</li></ul></li><li>一旦原文件被删除，该符号连接文件将无法打开</li><li>会占用inode和block</li><li>使用广泛</li></ul></li><li>硬连接、实际连接（hard link）</li><li style="list-style: none; display: inline"><ul><li>通过文件系统的inode连接产生新文件名而不是新文件</li><li>两文件名不同，但却具有相同的文件信息（包括inode号码）</li><li>当文件名被删除时，文件数据并没有被删除，可以通过其他硬连接的文件名访问</li><li>只是在目录下的block多写入一个关联数据，一般不占用磁盘空间与inode数目</li><li>限制</li><li style="list-style: none; display: inline"><ul><li>不能跨文件系统</li><li>不能连接目录（目录下的文件都需要对应连接，处理复杂）</li></ul></li><li>较安全</li></ul></li></ul></li><li>基本语法：ln [-sf] source destination</li><li style="list-style: none; display: inline"><ul><li>-s：symbolic link</li><li style="list-style: none; display: inline"><ul><li>默认为hard link</li></ul></li><li>-f：如果destination已存在，将主动删除source后重新创建</li></ul></li></ul></li><li>新增硬盘：分区、格式化（format）、检验文件系统、挂载</li><li>磁盘分区：fdisk</li><li style="list-style: none; display: inline"><ul><li>基本语法：fdisk [-l] devname</li><li style="list-style: none; display: inline"><ul><li>-l：输出后面接的设备所有的分区内容</li><li style="list-style: none; display: inline"><ul><li>若省略devname即“fdisk -l”表示列出整个系统内的所有分区</li></ul></li></ul></li><li>通常先用df命令找出可用磁盘文件名，再用fdisk命令</li><li>进入程序后，输入m可以查看帮助菜单，无需记住命令</li><li>主要命令</li><li style="list-style: none; display: inline"><ul><li>d：delete a partition（删除一个分区）</li><li style="list-style: none; display: inline"><ul><li>partition number：选择对应的分区序号即可</li></ul></li><li>n：add a new partition（新增一个分区）</li><li style="list-style: none; display: inline"><ul><li>选择分区形式</li><li style="list-style: none; display: inline"><ul><li>extended</li><li>primary partition</li><li>logicl</li></ul></li><li>partition number：设置分区序号</li><li>First cylinder：设置开始柱面号，直接[Enter]表示采用default值</li><li>Last cylinder：设置结束柱面号，直接[Enter]表示采用default值</li><li style="list-style: none; display: inline"><ul><li>除了输入柱面号，还可以直接输入磁盘分配的大小如+512M</li><li>系统自动计算最接近柱面号，但往往不恰好大小为512M</li></ul></li></ul></li><li>p：print the partition table（在屏幕上显示分区表）</li><li>q：quit without saving changes（离开，但不保存）</li><li>w：write table to disk and exit（将刚才的操作写入分区表，即保存）</li></ul></li><li>注意</li><li style="list-style: none; display: inline"><ul><li>该程序只有root能够打开，最好在单用户维护模式下操作</li><li>devname末尾不能加上数字，分区是针对整个设备而不是某个分区</li><li>如果硬盘某个分区还在使用中，系统内核很可能无法重载硬盘分区表</li><li style="list-style: none; display: inline"><ul><li>此时将分区卸载，重新分区即可</li><li>或者重启系统</li><li>或者调用GNU推出的工具partprobe命名告知内容读取新的分区表</li></ul></li><li>fdisk只能处理2TB以下的磁盘分区，当磁盘分区大于2TB时就要用到程序parted</li><li style="list-style: none; display: inline"><ul><li>基本语法：parted devname [命令 [参数] ]</li><li style="list-style: none; display: inline"><ul><li>注意devname是第一个参数！！</li><li>主要命令</li><li style="list-style: none; display: inline"><ul><li>新增分区：mkpart [primary|logical|extended] [ext3|vfat] 开始柱面 结束柱面</li><li style="list-style: none; display: inline"><ul><li>注意：这里的柱面必须用容量表示，而不能是柱面号</li><li>如：parted /dev/hdc mkpart logical ext3 19.2GB 19.7GB</li></ul></li><li>打印分区表：print</li><li style="list-style: none; display: inline"><ul><li>如：parted /dev/hdc print</li></ul></li><li>删除分区：rm [partition]</li><li style="list-style: none; display: inline"><ul><li>分区序号Number</li><li>如：parted /dev/hdc rm 8</li></ul></li></ul></li><li><br></li></ul></li></ul></li></ul></li></ul></li><li>简单的磁盘格式化（MaKe File System）：mkfs</li><li style="list-style: none; display: inline"><ul><li>基本语法：mkfs [-t] devname</li><li style="list-style: none; display: inline"><ul><li>-t：后接文件系统格式</li><li style="list-style: none; display: inline"><ul><li>如mkfs -t ext3 /dev/sda6</li></ul></li></ul></li><li>格式化时常用该命令，该命令使用默认值</li></ul></li><li>复杂的磁盘格式化：mke2fs</li><li style="list-style: none; display: inline"><ul><li>基本语法：mke2fs [-b SIZE] [-i SIZE] [-L LABEL] [-cj] devname</li><li style="list-style: none; display: inline"><ul><li>-b：设置block大小，后接数字（单位bytes），目前支持1024, 2048, 4096三种</li><li>-i：设置每个inode的大小，后接数字（单位bytes）</li><li>-c：检查磁盘错误</li><li style="list-style: none; display: inline"><ul><li>如果是“-c”，则进行快速读取测试（read）</li><li>如果是“-c -c”，则进行读写测试（read-write）</li></ul></li><li>-L：设置卷标，后接卷标名</li><li>-j：主动加入journal而成为EXT3</li><li style="list-style: none; display: inline"><ul><li>默认情况下为EXT2</li></ul></li></ul></li></ul></li><li>磁盘检查——文件系统（File System ChecK）：fsck</li><li style="list-style: none; display: inline"><ul><li>基本语法：fsck [-t TYPE] [-ACay] devname</li><li style="list-style: none; display: inline"><ul><li>-t：告诉程序设备的文件系统</li><li style="list-style: none; display: inline"><ul><li>但是现在的linux会自动通过super block去分辨文件系统，基本不需要这个参数</li></ul></li><li>-A：依据/etc/fstab的内容来将设备扫描一次</li><li style="list-style: none; display: inline"><ul><li>该命令在开机过程中会默认自动执行一次</li></ul></li><li>-a：自动修复检查到有问题的扇区，程序不再询问</li><li>-y：与-a类似，但是某些文件系统只支持-y</li><li>-C：检验过程中用一个直方图来显示目前进度</li><li>由e2fsck命令提供的针对EXT2/EXT3的参数</li><li style="list-style: none; display: inline"><ul><li>-f：强制检查</li><li style="list-style: none; display: inline"><ul><li>一般fsck对于没有发现任何unclean标志是不会主动进入细化检查的</li></ul></li><li>-D：针对文件系统下的目录进行优化配置</li></ul></li></ul></li><li>查看系统有多少文件系统支持fsck</li><li style="list-style: none; display: inline"><ul><li>fsck[tab][tab]</li><li>会列出文件系统相应的模块</li></ul></li><li>注意：</li><li style="list-style: none; display: inline"><ul><li>通常只有在系统出现极大问题，导致开机时不得不进入单用户模式下进行维护行为时，才使用此命令，否则可能造成对系统的伤害</li><li>执行fsck时，被检查的分区必须卸载</li><li style="list-style: none; display: inline"><ul><li>fsck在扫描硬盘时，可能会造成部分文件系统损坏</li></ul></li><li>检查过程中如果出现问题，有问题的数据会放在/lost+found目录下</li><li>执行fsck时，事实上是调用e2fsck这个软件</li></ul></li></ul></li><li>磁盘检查——坏区：badblocks</li><li style="list-style: none; display: inline"><ul><li>基本语法：badblocks [-svw] devname</li><li style="list-style: none; display: inline"><ul><li>-s：显示进度</li><li>-v：显示进度</li><li>-w：用写入的方式来测试</li><li style="list-style: none; display: inline"><ul><li>不要轻易使用，尤其是设备上有文件时</li></ul></li></ul></li><li>这个命令大多不用，因为“mke2fs -c devname”在格式化时会进行磁盘表面的读取测试</li></ul></li><li>磁盘挂载：mount</li><li style="list-style: none; display: inline"><ul><li>基本语法：mount [-a] [-l] [-t TYPE] [-L LABEL] [-o 其他选项] devname dirname</li><li style="list-style: none; display: inline"><ul><li>-a：依据配置文件/etc/fstab的数据将所有未挂载的磁盘都挂载上去</li><li>-l：增列Label名称</li><li style="list-style: none; display: inline"><ul><li>“mount”显示目前挂载信息，“mount -l”增加Label名称</li></ul></li><li>-t：指定文件系统类型</li><li>-n：本次挂载不写入/etc/mtab中</li><li style="list-style: none; display: inline"><ul><li>默认系统会将实际的挂载的情况写入/etc/mtab中，以利其他程序的运行</li><li>在某些情况下（例如单用户维护模式）为了避免问题，会刻意不写入</li></ul></li><li>-L：利用卷标名称来挂载</li><li style="list-style: none; display: inline"><ul><li>用卷标名来挂载的利弊</li><li style="list-style: none; display: inline"><ul><li>利：改变设备插口不会出现问题</li><li>弊：如果出现重复的Label会出现问题</li></ul></li><li>如果用了Label来挂载，那么卷标不能再随意修改，否则可能导致无法正常开机</li></ul></li><li>-o：额外的文件系统参数</li><li style="list-style: none; display: inline"><ul><li>ro, rw：挂载的文件系统成为只读（ro）或读写（rw）</li><li>async, sync：设置内存机制为同步写入（async）或异步写入（sync）</li><li style="list-style: none; display: inline"><ul><li>默认为async</li></ul></li><li>auto, noauto：是否允许此分区以mount -a自动挂载</li><li>dev, nodev：是否允许此分区上创建设备文件</li><li>suid, unsuid：是否允许此分区上含有suid/sgid的文件格式</li><li>exec, noexec：是否允许此分区上拥有可执行binary文件</li><li>user, nouser：是否允许让任何用户执行mount</li><li style="list-style: none; display: inline"><ul><li>nouser（默认）：只有root可执行</li><li>user：一般用户也可以执行</li></ul></li><li>usrquota：启动文件系统支持磁盘配额模式</li><li>grpquota：启动文件系统对群租磁盘配额模式的支持</li><li>defaults：默认值为rw, suid, dev, exec, auto, nouser, and async</li><li>remount：重新挂载，在系统出错，或者重新更新参数时很有用</li><li>【多个额外参数间用逗号（,）隔开】</li></ul></li></ul></li><li>由于文件系统几乎都有super block，linux可以自动分析super block搭配自己的驱动程序去测试挂载，所以以上大部分参数平时是不需要使用的</li><li style="list-style: none; display: inline"><ul><li>一般只需要用到mount devname dirname即可</li><li>linux只要参考了以下两个文件</li><li style="list-style: none; display: inline"><ul><li>/etc/filesystems：系统指定的文件系统类型</li><li>/proc/filesystems：系统已挂载的文件系统类型</li></ul></li><li>相关驱动在以下目录的设备同名子目录中</li><li style="list-style: none; display: inline"><ul><li>/lib/modules/$（uname -r）/kernel/fs</li></ul></li></ul></li><li>挂载CD或DVD光盘、软盘、U盘</li><li style="list-style: none; display: inline"><ul><li>先用mkdir新建一个目录</li><li>再用mount挂载（可不指定类型让系统识别）</li><li style="list-style: none; display: inline"><ul><li>CD或光盘的指定类型：-t iso9660</li><li>软盘、U盘：-t vfat</li><li>如果有中文文件名，可以加入-o iocharset=cp950</li></ul></li><li>如果要挂载NTFS文件系统可以参考以下网站</li><li style="list-style: none; display: inline"><ul><li>Linux-NTFSProject：http://www.linux-ntfs.org</li><li>下载相关驱动并安装，但是以后每次 升级系统都需要重新安装对应的驱动程序版本</li></ul></li></ul></li><li>重新挂载根目录</li><li style="list-style: none; display: inline"><ul><li>在单用户维护模式下，根目录会被系统挂载为只读</li><li>此时需要这样来重挂载根目录，使其可读写</li><li style="list-style: none; display: inline"><ul><li>mount -o remount,rw,auto /</li></ul></li></ul></li><li>将目录挂载到另一个目录上</li><li style="list-style: none; display: inline"><ul><li>类似符号连接</li><li>但是有的程序并不支持符号连接，此时就需要用到挂载并加入--bind参数</li><li>mount --bind dirname1 dirname2</li><li>将dirname1挂载到dirname2上，此时两个目录拥有相同的inode（与符号连接不同）</li></ul></li></ul></li><li>卸载设备文件：umount</li><li style="list-style: none; display: inline"><ul><li>基本语法：umount [-fn] dirname/mount point</li><li style="list-style: none; display: inline"><ul><li>-f：强制卸载</li><li>-n：不更新/etc/mtab</li></ul></li><li>如果进入该挂载点，即文件系统正被使用时，会提示“device is busy”而不能成功挂载</li></ul></li><li>磁盘参数修改：mknod</li><li style="list-style: none; display: inline"><ul><li>用ls命令查看设备文件的详细信息时，文件大小会被major和minor数值替代，两者用逗号隔开</li><li style="list-style: none; display: inline"><ul><li>major是主设备代码</li><li>minor是此设备代码</li><li>Linux内核认识的设备数据就是通过这两个数值决定的</li><li>常见硬盘文件名的设备代码如下
<table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">磁盘文件名</td><td valign="top">Major</td><td valign="top">Minor</td></tr><tr><td valign="top">/dev/hda</td><td valign="top">3</td><td valign="top">0~63</td></tr><tr><td valign="top">/dev/hdb</td><td valign="top">3</td><td valign="top">64~127</td></tr><tr><td valign="top">/dev/sda</td><td valign="top">8</td><td valign="top">0~15</td></tr><tr><td valign="top">/dev/sdb</td><td valign="top">8</td><td valign="top">16~31</td></tr></tbody></table><br></li><li>更多设备代码参考http://www.kernel.org/pub/linux/docs/device-list/devices.txt</li><li>Linux内核升级到2.6以后，硬件文件名已经能被系统自动实时产生，平时不需要手动创建</li></ul></li><li>基本语法：mknod devname [bcp] [Major] [Minor]</li><li style="list-style: none; display: inline"><ul><li>devname是第一个参数，而不是最后一个</li><li>[bcp]注意是没有减号的！</li><li style="list-style: none; display: inline"><ul><li>b：设置设备名称为一个外部存储设备文件，如硬盘</li><li>c：设置设备名称为一个外部输入设备文件，如鼠标、键盘</li><li>p：设置设备名称为一个FIFO文件</li></ul></li><li>[Major]：主设备代码</li><li>[Minor]：次设备代码</li></ul></li></ul></li><li>设置文件系统卷标：e2label</li><li style="list-style: none; display: inline"><ul><li>基本语法：e2label devname newLabel</li><li style="list-style: none; display: inline"><ul><li>如：e2label /dev/hdc6 my_test</li></ul></li></ul></li><li>小工具：tune2fs</li><li style="list-style: none; display: inline"><ul><li>功能：读取super block数据、将ext2转换为ext3、修改文件系统的label</li><li>基本语法：tune2fs [-jlL] devname</li><li style="list-style: none; display: inline"><ul><li>-j：将ext2转换为ext3</li><li>-l：读取设备super block内的数据（类似dumpe2fs -h）</li><li>-L：修改文件系统的Label（类似e2label）</li></ul></li></ul></li><li>IDE硬盘的高级参数设置：hdparm</li><li style="list-style: none; display: inline"><ul><li>这个命令的参数只适用于IDE硬盘</li><li>而SATA硬盘最多只能用该命令来测试性能，但并不是很准确，只能作为对比参考</li><li>基本语法：hdparm [-icdmXTt] devname</li><li style="list-style: none; display: inline"><ul><li>-i：显示内核检测到的硬盘参数</li><li>-c：设置32bit访问模式</li><li>-d：DMA模式</li><li style="list-style: none; display: inline"><ul><li>-d1为打开</li><li>-d0:为取消</li></ul></li><li>-m：同步读取多个sector的模式，降低系统因为读取硬盘而损耗性能</li><li style="list-style: none; display: inline"><ul><li>一般设置为16/32</li><li>不过西部数据建议值为4/8</li></ul></li><li>-X：UtraDMA模式</li><li>-T：测试暂存区cache的访问性能</li><li>-t：测试硬盘的实际访问性能</li></ul></li></ul></li><li>开机挂载/etc/fstab及/etc/mtab</li><li style="list-style: none; display: inline"><ul><li>设置开机自动挂载，直接修改文件/etc/fstab</li><li style="list-style: none; display: inline"><ul><li>限制</li><li style="list-style: none; display: inline"><ul><li>根目录/是必须挂载的，而且一定要先于其他挂载点被挂载进来</li><li>其他挂载点必须为已建好的目录，可以任意指定，但一定要遵守必需的系统目录架构原则</li><li>所有挂载点在同一时间内，只能挂载一次</li><li>所有分区在同一时间内，只能挂载一次</li><li>如果进行卸载。需要先将工作目录移到挂载点之外</li></ul></li><li>文件主要内容——六个字段，每个字段用空格隔开即可</li><li style="list-style: none; display: inline"><ul><li>第一字段Device：磁盘设备名或该设备的Label</li><li style="list-style: none; display: inline"><ul><li>如果是Label显示格式为“LABEL=......”</li></ul></li><li>第二字段Mount point：挂载点</li><li>第三字段filesystem：磁盘分区的文件系统</li><li style="list-style: none; display: inline"><ul><li>手动挂载时可以让系统自动检测</li><li>但是这里我们必须手动写入文件系统才行！</li></ul></li><li>第四字段parameters：文件系统参数</li><li style="list-style: none; display: inline"><ul><li>就是mount -o的那些参数</li><li>如果使用默认，在此处写入defaults即可</li></ul></li><li>第五字段dump：能否被dump备份命令作用</li><li style="list-style: none; display: inline"><ul><li>0代表不做dump备份</li><li>1代表每天都进行dump操作</li><li>2代表其他不定日期的dump操作</li></ul></li><li>第六字段fsck：开机过程是否以fsck检验扇区</li><li style="list-style: none; display: inline"><ul><li>0：不检验</li><li>1：最早检验（一般只有根目录设置为1）</li><li>2：稍晚检验（一般其他目录设置为2）</li></ul></li></ul></li></ul></li><li>系统的实际挂载情况是记录到/etc/mtab和/proc/mounts中的</li><li style="list-style: none; display: inline"><ul><li>每次改动文件系统的挂载时，会同时改动这两个文件</li></ul></li></ul></li><li>特殊设备loop挂载</li><li style="list-style: none; display: inline"><ul><li>挂载光盘镜像文件</li><li style="list-style: none; display: inline"><ul><li>mount -o loop （iso文件路径） （挂载点）</li><li style="list-style: none; display: inline"><ul><li>如mount -o loop /root/centos5.2_x86_64.iso /mnt/centos_dvd</li></ul></li><li>使用完毕后要即使卸载umount</li></ul></li><li>新建大文件来作为loop设备文件</li><li style="list-style: none; display: inline"><ul><li>相当于从有空闲的空间多划出了一个分区</li><li>创建大型文件：dd if=/dev/zero of=/home/loopdev bs=1M count=512</li><li style="list-style: none; display: inline"><ul><li>if是input file，输入文件，/dev/zero是一个一直输出0的设备</li><li>of是output file，将一堆零写入到该文件中</li><li>bs是每个block的大小，类似系统的block</li><li>count：block的数量</li></ul></li><li>格式化：mkfs -t ext3 /home/loopdev</li><li style="list-style: none; display: inline"><ul><li>此时因为不是正常的设备，会提示“Proceed anyway?(y, n)”，输入y即可</li></ul></li><li>挂载：mount -o loop /home/loopdev /media/cdrom</li></ul></li><li>构建内存交换空间（swap）</li><li style="list-style: none; display: inline"><ul><li>使用物理分区来构建</li><li style="list-style: none; display: inline"><ul><li>服务器最好能预留swap来缓冲一下</li><li>分区</li><li style="list-style: none; display: inline"><ul><li>新建分区（假设为/dev/hdc7）</li><li>由于linux的fdisk默认将分区ID设置为Linux文件系统</li><li>所以要手动修改，将ID从83改为82即可</li><li>更新分区表：partprobe</li></ul></li><li>构建swap格式：mkswap /dev/hdc7</li><li>加载swap：swapon /dev/hdc7</li><li>查看当前内存（物理内存和swap）：free</li><li>列出目前使用的swap设备有哪些：swapon -s</li></ul></li><li>使用文件来构建</li><li style="list-style: none; display: inline"><ul><li>新建大型文件：dd if=/dev/zero of=/tmp/swap bs=1M count=128</li><li>构建swap格式：mkswap /tmp/swap</li><li>加载swap：swapon /tmp/swap</li></ul></li><li>卸载swap（物理分区或者文件）</li><li style="list-style: none; display: inline"><ul><li>swapoff /dev/hdc7</li><li>或swapoff /tmp/swap</li></ul></li><li>swap的功能</li><li style="list-style: none; display: inline"><ul><li>当物理内存不够时，将某些在内存中所占用的程序暂时移动到swap当中，让物理内存可以被需要的程序使用</li><li>Linux主机系统进入“休眠”模式后，运行当中的程序状态会被记录到swap中去，作为“唤醒”主机的状态数据</li><li>有些程序在运行时，会利用swap的特性来存放某些数据段</li></ul></li><li>swap使用限制</li><li style="list-style: none; display: inline"><ul><li>在内核2.4.10版本后，单一swap已经没有2GB的限制</li><li>最多仅能创建32个swap</li><li>由于目前64位系统最大内存寻址为64位（Windows支持超过哦128GB的内存），因此swap总量最大也只能达到64G</li></ul></li></ul></li></ul></li><li><br></li></ul></div>
</div></a></body></html>\00
